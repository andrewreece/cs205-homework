Notes: 
(1) See small multiples graph "P5-comparisons.png" for all speed comparisons mentioned in writeup, except where noted.
(2) All performance observations are for 10,000 balls with radius=0.002, except where noted.

Part 1: Multithreading

With prange() in the three sections specified, FPS slowed considerably with 4 threads compared to 1 thread (p5-pt1-a.png).  Ray advised that I only use prange for the loop around sub_update (see Piazza @454), and when I did that, 4 threads ran faster than 1 thread (this is difficult to see on the P5-comparisons graph with 10k balls, so see p5-pt1-b.png, which was generated with only 500 balls).  

According to Ray, in some setups (like mine), "the compiler gets confused about the modifications in the loop and adds memory barriers at the end of each iteration".  The speedup we do see around iterating sub_update makes sense, as the for-loop over all balls in there is expensive and works faster when distributed across threads.


Part 2: Spatial decomposition

Using the local grid search for this problem saw significant speedups, by more than an order of magnitude.  Four threads performed faster than one thread, but had a notable left tail, meaning that occasionally there were big slowdowns on some updates.  The move to local grid search gave the best performance gains out of any of the modifications in this problem, which make sense as it essentially reduced the asymptotic runtime from O(N^2) to O(N).


Part 3: Spatially-Coherent Sorting

I implemented Hilbert sorting, modified from the C code provided on the Hilbert Curve Wikipedia entry.  I chose Hilbert order because it was suggested, and I chose Hilbert over Morton because I understood the code in its Wikipedia entry better than I did the Morton code in its respective Wiki entry.  

Sorting saw strong gains for both 1-thread and 4-thread conditions.  4-thread gains were a bit more modest but notable nonetheless.  This makes sense as the sorted values were closer together in memory, and so faster to locate during runtime.


Part 4: Locking

Fine-grained locking erased the gains we saw from Hilbert sorting, maybe slightly degrading even from Part 2's performance average. We learned in P2 that fine-grained locking is expensive, so this does not come as a surprise.  The trade-off we gain by using a lock for each ball is in the integrity of the physics simulator (ie. no simultaneous updating), and in a use case where accurate simulation trumps rendering speed, it would be worth it to take the hit in performance to ensure accuracy.

